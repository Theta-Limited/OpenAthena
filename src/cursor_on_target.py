#!/usr/bin/env python3
"""
cursor_on_target.py

This module implements Cursor on Target (CoT) functionality for the OpenAthena project.
It provides functions to create, format, and send CoT messages over a UDP multicast network.

CoT is a XML-based schema for sharing location information between different systems.
This implementation focuses on sending location data from drone imagery analysis.

The module uses the following libraries:
- xml.etree.ElementTree for XML creation
- uuid for generating unique identifiers
- time for timestamping
- socket for network communication

Usage:
    Import this module and use the create_and_send_cot function to send CoT messages
    with resolved target information.

Note:
    This implementation uses UDP multicast by default, which may not be suitable
    for all network environments. Ensure your network supports multicast before use.
"""

import xml.etree.ElementTree as ET
import uuid
import time
import socket
#import struct
import socket
import logging

"""
    Generate a unique identifier for CoT messages.

    Returns:
    str: A unique identifier string prefixed with 'OpenAthena-'.

    Note:
    This function uses UUID4 to ensure uniqueness across multiple instances
    and executions of the software.
"""
def create_uid():
    return f"OpenAthena-{uuid.uuid4()}"

"""
    Construct a CoT XML message.

    Parameters:
    lat (float): Latitude of the target in decimal degrees.
    lon (float): Longitude of the target in decimal degrees.
    alt (float): Altitude of the target in meters above WGS84 ellipsoid.
    ce (float): Circular error of the position estimate in meters.
    le (float): Linear error of the altitude estimate in meters.

    Returns:
    str: A formatted XML string representing the CoT message.

    Note:
    The function sets the CoT event type to 'a-p-G' (Assumed friend - Pending - Ground)
    and the 'how' attribute to 'h-c' (Human - Calculated).
"""
def build_cot_xml(lat, lon, alt, ce, le):
    root = ET.Element("event")
    root.set("version", "2.0")
    root.set("uid", create_uid())
    root.set("type", "a-p-G")
    root.set("how", "h-c")
    root.set("time", time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()))
    root.set("start", time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()))
    root.set("stale", time.strftime("%Y-%m-%dT%H:%M:%S", time.gmtime(time.time() + 180)))  # 3 minutes from now

    point = ET.SubElement(root, "point")
    point.set("lat", str(lat))
    point.set("lon", str(lon))
    point.set("hae", str(alt))
    point.set("ce", str(ce))
    point.set("le", str(le))

    detail = ET.SubElement(root, "detail")
    precisionlocation = ET.SubElement(detail, "precisionlocation")
    precisionlocation.set("altsrc", "DTED2")
    precisionlocation.set("geopointsrc", "GPS")

    remarks = ET.SubElement(detail, "remarks")
    remarks.text = "Generated by OpenAthena from sUAS data"

    return ET.tostring(root, encoding="utf-8")


"""
    Create and configure a UDP socket for multicast transmission.

    Parameters:
    multicast_group (str): The IP address of the multicast group.
    port (int): The UDP port number to use.

    Returns:
    socket.socket: A configured UDP multicast socket.

    Note:
    The socket is configured with a TTL of 32, which should be sufficient
    for most local network environments.
"""
def setup_multicast_socket(multicast_group, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 32)
    return sock

"""
    Send a CoT message over a multicast UDP socket with error handling and retries.

    Parameters:
    sock (socket.socket): The UDP socket to use for sending.
    message (str): The CoT XML message to send.
    multicast_group (str): The IP address of the multicast group.
    port (int): The UDP port number to use.
    max_retries (int, optional): Maximum number of send attempts. Defaults to 3.

    Returns:
    bool: True if the message was sent successfully, False otherwise.

    Raises:
    socket.error: If there's a persistent network error after all retries.

    Note:
    This function implements a simple retry mechanism for handling transient
    network errors. It will attempt to send the message up to 'max_retries'
    times before giving up. All errors are logged for debugging purposes.
    """
def send_cot_message(sock, message, multicast_group, port, max_retries=3):
    retries = 0
    while retries < max_retries:
        try:
            sock.sendto(message, (multicast_group, port))
            logging.info(f"CoT message sent successfully to {multicast_group}:{port}")
            return True
        except socket.error as e:
            retries += 1
            logging.warning(f"Attempt {retries}/{max_retries} failed. Error: {str(e)}")
            if retries == max_retries:
                logging.error(f"Failed to send CoT message after {max_retries} attempts")
                raise  # Re-raise the last exception
    return False

"""
    Create a CoT message and send it over a multicast network.

    This function combines the creation and sending of a CoT message into a single call.

    Parameters:
    lat (float): Latitude of the target in decimal degrees.
    lon (float): Longitude of the target in decimal degrees.
    alt (float): Altitude of the target in meters above WGS84 ellipsoid.
    ce (float, optional): Circular error of the position estimate in meters. Defaults to 15.0.
    le (float, optional): Linear error of the altitude estimate in meters. Defaults to 20.0.
    multicast_group (str, optional): The IP address of the multicast group. Defaults to '239.2.3.1'.
    port (int, optional): The UDP port number to use. Defaults to 6969.

    Returns:
    bool: True if the message was sent successfully, False otherwise.

    Note:
    The default ce and le values are conservative estimates and should be replaced
    with more accurate values when available from sensor data or calculations.
    This function will attempt to send the message multiple times in case of network errors.
"""
def create_and_send_cot(lat, lon, alt, ce=7.5, le=15.0, multicast_group='239.2.3.1', port=6969):
    cot_message = build_cot_xml(lat, lon, alt, ce, le)
    sock = setup_multicast_socket(multicast_group, port)
    try:
        result = send_cot_message(sock, cot_message, multicast_group, port)
        return result
    except socket.error as e:
        logging.error(f"Failed to send CoT message: {str(e)}")
        return False
    finally:
        sock.close()

if __name__ == "__main__":
    # Example usage
    create_and_send_cot(29.204774, -80.999010, 40.062605, 27.439030, 5.0)